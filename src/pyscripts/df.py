'''
 # @ Author: Mo David
 # @ Create Time: 2024-06-28 17:58:14
 # @ Modified time: 2024-06-28 17:58:22
 # @ Description:

 This file has our implementation of the df monad.
 This allows us to wrap our data in a type that allows some easier manips.
 '''

class DF:
  '''
  This class defines a wrapper around dataframe instances.
  '''

  # Static variables
  # Stores all our wrapped dataframes
  __dfs = {}

  def __init__(self, id, dataframe, logs, error):
    '''
    Initializes the dataframe wrapper.
    Also pushes the instantiated dataframe to the __dfs variable.
    '''
    self.__id = id
    self.__dataframe = dataframe
    self.__logs = logs
    self.__error = error

    # Save the wrapped dataframe
    DF.__dfs[id] = self

  def get_id(self):
    '''
    Retrieves the id of the wrapped dataframe.
    '''
    return self.__id

  def get_df(self):
    '''
    Retrieves the dataframe stored by the wrapper.
    '''
    return self.__dataframe

  def get_logs(self):
    '''
    Retrieves the complete set of logs generated by the wrapper.
    '''
    return self.__logs

  def get_error(self):
    '''
    Retrieves the first error encountered in the chain.
    '''
    return self.__error

  def map(self, f):
    '''
    This function maps the dataframe to its new value using the given callback.
    If the dataframe is invalid, we don't bother executing the function.
    '''

    # The dataframe was invalid
    if self.__dataframe is None:

      # Define the log first
      log = '({}) Failed to apply {}.'.format(len(self.__logs), f.__name__)

      # Return an empty wrapper
      return DF(self.__id, None, self.__logs + [ log ], self.__error)

    # Evaluate the result and error, if any
    result, log, error, *_ = f(self.__dataframe) + (None, None)

    # If no log was given, define it here
    # Otherwise, format it properly
    if log:
      log = '({}) {}'.format(len(self.__logs), log) 
    else:
      log = '({}) Applied {}.'.format(len(self.__logs), f.__name__)

    # If no error was given
    error = error or self.__error or None

    # Map the original value elsewhere
    return DF(self.__id, result, self.__logs + [ log ], error)

  @staticmethod
  def of(id, dataframe):
    '''
    This function creates an instance of the wrapper class.
    It provides the defaults of the other parameters.
    '''
    return DF(id, dataframe, [], None)

  @staticmethod
  def get(id):
    '''
    This function returns the raw (unwrapped) dataframe with the given id.
    '''
    return DF.__dfs[id].get_df()

  @staticmethod
  def get_ids():
    '''
    Retrieves a list of all ids of the wrapped dataframes in the class.
    '''
    return DF.__dfs.keys()

# Progress log
print('PYTHON: Loaded df.py.')
